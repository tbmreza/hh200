-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParHh
  ( happyError
  , myLexer
  , pListConfigItem
  , pListBinding
  , pListStr
  , pListInt
  , pStr
  , pInt
  , pScript
  , pListTopLevel
  , pTopLevel
  , pConfigBlock
  , pConfigItem
  , pCallItem
  , pDepsClause
  , pRequest
  , pBinding
  , pResponse
  , pResponseBody
  , pCaptures
  , pAsserts
  , pMethod
  , pUrl
  ) where

import Prelude

import qualified AbsHh
import LexHh

}

%name pListConfigItem ListConfigItem
%name pListBinding ListBinding
%name pListStr ListStr
%name pListInt ListInt
%name pStr Str
%name pInt Int
%name pScript Script
%name pListTopLevel ListTopLevel
%name pTopLevel TopLevel
%name pConfigBlock ConfigBlock
%name pConfigItem ConfigItem
%name pCallItem CallItem
%name pDepsClause DepsClause
%name pRequest Request
%name pBinding Binding
%name pResponse Response
%name pResponseBody ResponseBody
%name pCaptures Captures
%name pAsserts Asserts
%name pMethod Method
%name pUrl Url
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  ':'        { PT _ (TS _ 1)  }
  'Asserts'  { PT _ (TS _ 2)  }
  'Captures' { PT _ (TS _ 3)  }
  'Configs'  { PT _ (TS _ 4)  }
  'DELETE'   { PT _ (TS _ 5)  }
  'GET'      { PT _ (TS _ 6)  }
  'HEAD'     { PT _ (TS _ 7)  }
  'HTTP'     { PT _ (TS _ 8)  }
  'OPTIONS'  { PT _ (TS _ 9)  }
  'PATCH'    { PT _ (TS _ 10) }
  'POST'     { PT _ (TS _ 11) }
  'PUT'      { PT _ (TS _ 12) }
  '['        { PT _ (TS _ 13) }
  ']'        { PT _ (TS _ 14) }
  'then'     { PT _ (TS _ 15) }
  '{'        { PT _ (TS _ 16) }
  '}'        { PT _ (TS _ 17) }
  L_Ident    { PT _ (TV $$)   }
  L_integ    { PT _ (TI $$)   }
  L_quoted   { PT _ (TL $$)   }

%%

Ident :: { AbsHh.Ident }
Ident  : L_Ident { AbsHh.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

ListConfigItem :: { [AbsHh.ConfigItem] }
ListConfigItem
  : {- empty -} { [] } | ConfigItem ListConfigItem { (:) $1 $2 }

ListBinding :: { [AbsHh.Binding] }
ListBinding
  : {- empty -} { [] } | Binding ListBinding { (:) $1 $2 }

ListStr :: { [AbsHh.Str] }
ListStr : {- empty -} { [] } | Str ListStr { (:) $1 $2 }

ListInt :: { [AbsHh.Int] }
ListInt : {- empty -} { [] } | Int ListInt { (:) $1 $2 }

Str :: { AbsHh.Str }
Str : String { AbsHh.Str $1 }

Int :: { AbsHh.Int }
Int : Integer { AbsHh.Int $1 }

Script :: { AbsHh.Script }
Script : ListTopLevel { AbsHh.Script $1 }

ListTopLevel :: { [AbsHh.TopLevel] }
ListTopLevel
  : {- empty -} { [] } | TopLevel ListTopLevel { (:) $1 $2 }

TopLevel :: { AbsHh.TopLevel }
TopLevel
  : ConfigBlock { AbsHh.TopLevelConfig $1 }
  | CallItem { AbsHh.TopLevelCall $1 }

ConfigBlock :: { AbsHh.ConfigBlock }
ConfigBlock
  : '[' 'Configs' ']' ListConfigItem { AbsHh.ConfigBlock $4 }

ConfigItem :: { AbsHh.ConfigItem }
ConfigItem : Ident ':' String { AbsHh.ConfigItem $1 $3 }

CallItem :: { AbsHh.CallItem }
CallItem
  : DepsClause Request Response { AbsHh.CallItem $1 $2 $3 }
  | DepsClause Request { AbsHh.CallItemNoResponse $1 $2 }

DepsClause :: { AbsHh.DepsClause }
DepsClause
  : ListStr 'then' String { AbsHh.DepsClause $1 $3 }
  | String { AbsHh.NoDepsClause $1 }

Request :: { AbsHh.Request }
Request
  : Method Url ListBinding '{' String '}' { AbsHh.Request $1 $2 $3 $5 }
  | Method Url ListBinding { AbsHh.RequestNoPayload $1 $2 $3 }
  | Method Url '{' String '}' { AbsHh.RequestNoBindings $1 $2 $4 }
  | Method Url { AbsHh.RequestMin $1 $2 }

Binding :: { AbsHh.Binding }
Binding : Ident ':' String { AbsHh.Binding $1 $3 }

Response :: { AbsHh.Response }
Response
  : 'HTTP' ListInt ResponseBody { AbsHh.Response $2 $3 }
  | ResponseBody { AbsHh.ResponseNoCodes $1 }

ResponseBody :: { AbsHh.ResponseBody }
ResponseBody
  : Captures Asserts { AbsHh.ResponseBody $1 $2 }
  | Captures { AbsHh.ResponseBodyCapturesOnly $1 }
  | Asserts { AbsHh.ResponseBodyAssertsOnly $1 }

Captures :: { AbsHh.Captures }
Captures : '[' 'Captures' ']' ListBinding { AbsHh.Captures $4 }

Asserts :: { AbsHh.Asserts }
Asserts : '[' 'Asserts' ']' ListStr { AbsHh.Asserts $4 }

Method :: { AbsHh.Method }
Method
  : 'GET' { AbsHh.MethodGET }
  | 'POST' { AbsHh.MethodPOST }
  | 'PUT' { AbsHh.MethodPUT }
  | 'DELETE' { AbsHh.MethodDELETE }
  | 'PATCH' { AbsHh.MethodPATCH }
  | 'OPTIONS' { AbsHh.MethodOPTIONS }
  | 'HEAD' { AbsHh.MethodHEAD }

Url :: { AbsHh.Url }
Url : Ident { AbsHh.Url $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}
